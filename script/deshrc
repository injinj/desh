# /etc/deshrc
# This is read for interactive shells
#
# Order of profile loading:
#   /etc/deshenv       # all shell starts
#   ~/.deshenv
#   /etc/deshprofile   # only login shell starts
#   ~/.deshprofile
#   /etc/deshrc        # only interactive shell starts
#   ~/.deshrc

# unalias:
# remove fn-X
# reverses imply and alias below
fn unalias {
  if {$#* :gt 0} {
    fn-$1=
  } {
    echo 'usage: unalias cmd'
  }
}

# imply:
# prepends arguments to subsequent execution
#
# if this is 'imply'ed
# imply cmd -bongo
#
# then if this is entered:
# cmd hello
#
# it causes this to execute:
# cmd -bongo hello
#
fn imply {
  if {$#* :gt 1} {
    let ((cmd args) = $*) {
      unalias $cmd
      let (cmd2 = <={%whatis $cmd}) {
        fn $cmd {
          $cmd2 $args $*
        }
      }
    }
  } {
    echo 'usage: imply cmd args'
  }
}

#
# alias
# renames a command to another command
#
# alias ls ls '--color=auto'
#
# is equivalent to
#
# imply ls '--color=auto'
#
fn alias {
  if {$#* :gt 1} {
    let ((name cmd args) = $*) {
      unalias $name
      let (cmd2 = <={%whatis $cmd}) {
        fn $name {
          $cmd2 $args $*
        }
      }
    }
  } {
    echo 'usage: alias name cmd args'
  }
}

#
# fgcolor
# returns the ansi escape code for a color
#
# this should display hello world in red:
#
# echo <={fgcolor Red} hello world <={fgcolor}
#
# color pallete for 8-bit here:
# https://en.wikipedia.org/wiki/ANSI_escape_code
#
# 8-bit is 256 colors, all of the predefined 38;5;X are on this pallete
# 24-bit is RGB based
#
fn fgcolor {
  let (ESC = \033) {
    if {~ $1 'Black'}            { return $ESC ^ '[30m'
    }  {~ $1 'Red'}              { return $ESC ^ '[31m'
    }  {~ $1 'Green'}            { return $ESC ^ '[32m'
    }  {~ $1 'Yellow'}           { return $ESC ^ '[33m'
    }  {~ $1 'Blue'}             { return $ESC ^ '[34m'
    }  {~ $1 'Magenta'}          { return $ESC ^ '[35m'
    }  {~ $1 'Cyan'}             { return $ESC ^ '[36m'
    }  {~ $1 'White'}            { return $ESC ^ '[37m'
    }  {~ $1 'NavyBlue'}         { return $ESC ^ '[38;5;17m'
    }  {~ $1 'DarkBlue'}         { return $ESC ^ '[38;5;18m'
    }  {~ $1 'DarkGreen'}        { return $ESC ^ '[38;5;22m'
    }  {~ $1 'DarkCyan'}         { return $ESC ^ '[38;5;36m'
    }  {~ $1 'LightSeaGreen'}    { return $ESC ^ '[38;5;37m'
    }  {~ $1 'DarkTurquoise'}    { return $ESC ^ '[38;5;44m'
    }  {~ $1 'DarkRed'}          { return $ESC ^ '[38;5;52m'
    }  {~ $1 'BlueViolet'}       { return $ESC ^ '[38;5;57m'
    }  {~ $1 'SteelBlue'}        { return $ESC ^ '[38;5;67m'
    }  {~ $1 'CornflowerBlue'}   { return $ESC ^ '[38;5;69m'
    }  {~ $1 'CadetBlue'}        { return $ESC ^ '[38;5;72m'
    }  {~ $1 'MediumTurquoise'}  { return $ESC ^ '[38;5;80m'
    }  {~ $1 'DarkRed'}          { return $ESC ^ '[38;5;88m'
    }  {~ $1 'DarkMagenta'}      { return $ESC ^ '[38;5;90m'
    }  {~ $1 'DarkViolet'}       { return $ESC ^ '[38;5;92m'
    }  {~ $1 'Purple'}           { return $ESC ^ '[38;5;93m'
    }  {~ $1 'LightSlateGrey'}   { return $ESC ^ '[38;5;103m'
    }  {~ $1 'MediumPurple'}     { return $ESC ^ '[38;5;104m'
    }  {~ $1 'LightSlateBlue'}   { return $ESC ^ '[38;5;105m'
    }  {~ $1 'DarkSeaGreen'}     { return $ESC ^ '[38;5;108m'
    }  {~ $1 'LightGreen'}       { return $ESC ^ '[38;5;120m'
    }  {~ $1 'MediumVioletRed'}  { return $ESC ^ '[38;5;126m'
    }  {~ $1 'DarkViolet'}       { return $ESC ^ '[38;5;128m'
    }  {~ $1 'IndianRed'}        { return $ESC ^ '[38;5;131m'
    }  {~ $1 'MediumOrchid'}     { return $ESC ^ '[38;5;134m'
    }  {~ $1 'DarkGoldenrod'}    { return $ESC ^ '[38;5;136m'
    }  {~ $1 'RosyBrown'}        { return $ESC ^ '[38;5;138m'
    }  {~ $1 'DarkKhaki'}        { return $ESC ^ '[38;5;143m'
    }  {~ $1 'LightSteelBlue'}   { return $ESC ^ '[38;5;147m'
    }  {~ $1 'GreenYellow'}      { return $ESC ^ '[38;5;154m'
    }  {~ $1 'Orchid'}           { return $ESC ^ '[38;5;170m'
    }  {~ $1 'Violet'}           { return $ESC ^ '[38;5;177m'
    }  {~ $1 'Tan'}              { return $ESC ^ '[38;5;180m'
    }  {~ $1 'HotPink'}          { return $ESC ^ '[38;5;206m'
    }  {~ $1 'DarkOrange'}       { return $ESC ^ '[38;5;208m'
    }  {~ $1 'SandyBrown'}       { return $ESC ^ '[38;5;215m'
    }  {~ $1 'Grey'}             { return $ESC ^ '[38;5;244m'
    }  {~ $1 '8-bit'} {
      let (c = $2) {
        return $ESC ^ '[38;5;' ^ $c ^ 'm'
      }
    }  {~ $1 '24-bit'} {
      let (r = $2; g = $3; b = $4) {
        return $ESC ^ '[38;2;' ^ $r ^ ';' ^ $g ^ ';' ^ $b ^ 'm'
      }
    }  {~ $1 'BrightBlack'}   { return $ESC ^ '[90m'
    }  {~ $1 'BrightRed'}     { return $ESC ^ '[91m'
    }  {~ $1 'BrightGreen'}   { return $ESC ^ '[92m'
    }  {~ $1 'BrightYellow'}  { return $ESC ^ '[93m'
    }  {~ $1 'BrightBlue'}    { return $ESC ^ '[94m'
    }  {~ $1 'BrightMagenta'} { return $ESC ^ '[95m'
    }  {~ $1 'BrightCyan'}    { return $ESC ^ '[96m'
    }  {~ $1 'BrightWhite'}   { return $ESC ^ '[97m'
    }                         { return $ESC ^ '[0m' }
  }
}

# prompt[ 0 ] is primary proomt;  this is used below:
#  '\u@\h:\w\R' ^ $prompt_git_status ^ ' \l ' $os_container_string ^ '\n[\!]; '
#
# <user>@<host>:<pwd>                     [git-status] <tty> <container-id>
# [hist#]; 
#
# prompt[ 1 ] is secondary prompt for line continuations
# prompt[ 2 ] is vi insert mode
# prompt[ 3 ] is vi command mode
# prompt[ 4 ] is emacs mode
# prompt[ 5 ] is search mode
# prompt[ 6 ] is TAB complete mode
# prompt[ 7 ] is visual select mode
# prompt[ 8 ] is ouch / bell
# prompt[ 9 ] is left select cursor
# prompt[ 10 ] is right select cursor

# on 'cd', this is set to 'git status' if git is present
prompt_git_status = 'initial'
# this can be set later to display a container id on the right of the prompt
os_container_string = ''

if {access -x /usr/bin/lsb_release} {
  osver=`{/usr/bin/lsb_release -rs | sed 's/[.].*//'}
  osdist=`{/usr/bin/lsb_release -i | sed 's/.*:\t//'}

  if {~ $osdist 'Fedora'} {
    os_container_string = 'FC' ^ $osver
  } {~ $osdist 'CentOS' || ~ $osdist 'RedHat' || ~ $osdist 'RedHatEnterprise'} {
    os_container_string = 'RH' ^ $osver
  } {~ $osdist 'Debian'} {
    os_container_string = 'DEB' ^ $osver
  } {~ $osdist 'Ubuntu'} {
    os_container_string = 'UB' ^ $osver
  } {~ $osdist 'SUSE' || ~ $osdist 'OpenSUSE'} {
    os_container_string = 'SS' ^ $osver
  } {~ $osdist 'Slackware'} {
    os_container_string = 'SL' ^ $osver
  } {~ $osdist 'Arch'} {
    os_container_string = 'AR' ^ $osver
  }
}

fn git_branch_decoder {
  let ( branch   = ''
        upstream = ''
        ahead    = 0
        untacked = 0
        modified = 0
        renamed  = 0
        deleted  = 0
        added    = 0
        indexed  = 0
        other    = 0
        r        = ''
        i        = <={%read} ) {
    while {$#i :gt 0} {
      let ( j = <={%split ' ' $i} ) {
        if {~ $j(1) '##'} {
          let ( k = <={%split '...' $j(2)} ) {
            branch   = $k(1)
            upstream = $k(2)
          }
          # match [ahead 1] or [behind 1]
          if {$#j :gt 2} {
            let ( where = <={%split '[' $j(3)}
                  count = <={%split ']' $j(4)} ) {
              if {~ $where 'ahead'} {
                ahead = $count
              } {~ $where 'behind'} {
                ahead = <={%neg $count}
              }
            }
          }
        } {~ $j(1) '??'} {
          untracked = <={%sum $untracked 1}
        } {~ $j(1) *M*} {
          modified = <={%sum $modified 1}
        } {~ $j(1) *R*} {
          # renamed
          indexed = <={%sum $indexed 1}
        } {~ $j(1) *D*} {
          # deleted
          indexed = <={%sum $indexed 1}
        } {~ $j(1) *A*} {
          # added
          indexed = <={%sum $indexed 1}
        } {
          other = <={%sum $other 1}
        }
      }
      i = <={%read}
    }
    let (BR_COLOR   = ''
         BR_NOCOLOR = ''
         no_change  = 0) {
      no_change = <={%sum $modified $indexed}
      if {$ahead :ne 0} {
        no_change = <={%sum $no_change 1}
      }
      if {$howmanycolors :ge 8} {
        if {$no_change :eq 0} {
          BR_COLOR = <={fgcolor 'Green'}
        } {
          BR_COLOR = <={fgcolor 'Red'}
        }
        BR_NOCOLOR = <={fgcolor}
      }
      r = $BR_COLOR ^ '[' ^ $branch
      if {$ahead :gt 0} {
        r = $r ^ '+' ^ $ahead
      } {$ahead :lt 0} {
        r = $r ^ '-' ^ $ahead
      } {
        r = $r
      }
      r = $r ^ ']'
      if {$modified :gt 0} {
        r = $r ^ '~' ^ $modified
      }
      if {$indexed :gt 0} {
        r = $r ^ '+' ^ $indexed
      }
      r = $r ^ $BR_NOCOLOR
      echo -n $r
    }
  }
}

fn set_prompt_256 {
  # used to turn color escape off, normal text mode
  let (NO_COLOR      = <={fgcolor}
       # some colors used below
       USER_COLOR    = <={fgcolor 'LightSlateBlue'}
       HOST_COLOR    = <={fgcolor 'BrightYellow'}
       PWD_COLOR     = <={fgcolor 'Green'}
       PROMPT2_COLOR = <={fgcolor 'Orchid'}
       HIST_COLOR    = <={fgcolor 'BrightCyan'}
       TTY_COLOR     = <={fgcolor 'MediumPurple'}
       TIME_COLOR    = <={fgcolor 'DarkGoldenrod'}
       INS_COLOR     = <={fgcolor 'BrightGreen'}
       CMD_COLOR     = <={fgcolor 'Magenta'}
       EMACS_COLOR   = <={fgcolor 'BrightGreen'}
       SRCH_COLOR    = <={fgcolor 'Cyan'}
       COMP_COLOR    = <={fgcolor 'Magenta'}
       VISU_COLOR    = <={fgcolor 'Cyan'}
       OUCH_COLOR    = <={fgcolor 'BrightRed'}
       SEL1_COLOR    = <={fgcolor 'HotPink'}
       SEL2_COLOR    = <={fgcolor 'HotPink'}) {

# take out for now, causes unruly scrollbar
# $TIME_COLOR    ^ '\@'   ^ $NO_COLOR ^ '\n' ^

  prompt = ( $USER_COLOR    ^ '\u'   ^ $NO_COLOR ^ '@'  ^
             $HOST_COLOR    ^ '\h'   ^ $NO_COLOR ^ ':'  ^
             $PWD_COLOR     ^ '\w'   ^ $NO_COLOR ^ '\R' ^
             $prompt_git_status      ^ ' ' ^
             $TTY_COLOR     ^ '\l'   ^ ' ' ^
             $os_container_string    ^ $NO_COLOR ^ '\n' ^
             $HIST_COLOR    ^ '[\!]' ^ $NO_COLOR ^ '; '
             $PROMPT2_COLOR ^ '> '   ^ $NO_COLOR
             $INS_COLOR     ^ '<-i'  ^ $NO_COLOR
             $CMD_COLOR     ^ '|=c'  ^ $NO_COLOR
             $EMACS_COLOR   ^ '<-e'  ^ $NO_COLOR
             $SRCH_COLOR    ^ '/_?'  ^ $NO_COLOR
             $COMP_COLOR    ^ 'TAB'  ^ $NO_COLOR
             $VISU_COLOR    ^ '[-]'  ^ $NO_COLOR
             $OUCH_COLOR    ^ '?@&!' ^ $NO_COLOR
             $SEL1_COLOR    ^ '['    ^ $NO_COLOR
             $SEL2_COLOR    ^ ']'    ^ $NO_COLOR )
  }
}

fn set_prompt_8 {
  # used to turn color escape off, normal text mode
  let (NO_COLOR      = <={fgcolor}
       # some colors used below
       USER_COLOR    = <={fgcolor 'Cyan'}
       HOST_COLOR    = <={fgcolor 'Magenta'}
       PWD_COLOR     = <={fgcolor 'Green'}
       PROMPT2_COLOR = <={fgcolor 'Cyan'}
       HIST_COLOR    = <={fgcolor 'Cyan'}
       TTY_COLOR     = <={fgcolor 'Cyan'}
       TIME_COLOR    = <={fgcolor 'Cyan'}
       INS_COLOR     = <={fgcolor 'Green'}
       CMD_COLOR     = <={fgcolor 'Magenta'}
       EMACS_COLOR   = <={fgcolor 'Green'}
       SRCH_COLOR    = <={fgcolor 'Cyan'}
       COMP_COLOR    = <={fgcolor 'Magenta'}
       VISU_COLOR    = <={fgcolor 'Cyan'}
       OUCH_COLOR    = <={fgcolor 'Red'}
       SEL1_COLOR    = <={fgcolor 'Red'}
       SEL2_COLOR    = <={fgcolor 'Red'}) {


  prompt = ( $USER_COLOR    ^ '\u'   ^ $NO_COLOR ^ '@'  ^
             $HOST_COLOR    ^ '\h'   ^ $NO_COLOR ^ ':'  ^
             $PWD_COLOR     ^ '\w'   ^ $NO_COLOR ^ '\R' ^
             $prompt_git_status      ^ ' ' ^
             $TTY_COLOR     ^ '\l'   ^ ' ' ^
             $os_container_string    ^ $NO_COLOR ^ '\n'  ^
             $HIST_COLOR    ^ '[\!]' ^ $NO_COLOR ^ '; '
             $PROMPT2_COLOR ^ '> '   ^ $NO_COLOR
             $INS_COLOR     ^ '<-i'  ^ $NO_COLOR
             $CMD_COLOR     ^ '|=c'  ^ $NO_COLOR
             $EMACS_COLOR   ^ '<-e'  ^ $NO_COLOR
             $SRCH_COLOR    ^ '/_?'  ^ $NO_COLOR
             $COMP_COLOR    ^ 'TAB'  ^ $NO_COLOR
             $VISU_COLOR    ^ '[-]'  ^ $NO_COLOR
             $OUCH_COLOR    ^ '?@&!' ^ $NO_COLOR
             $SEL1_COLOR    ^ '['    ^ $NO_COLOR
             $SEL2_COLOR    ^ ']'    ^ $NO_COLOR )
  }
}

fn set_prompt_nocolor {
  prompt = ( '\u@\h:\w\R' ^ $prompt_git_status ^ ' \l ' ^
             $os_container_string ^ '\n[\!]; '
             '> '
             '<-i'
             '|=c'
             '<-e'
             '/_?'
             'TAB'
             '[-]'
             '?@&!'
             '['
             ']' )
}

howmanycolors = `{tput colors}
if {$howmanycolors :lt 8} {
  # force xterm to have colors
  if {~ $TERM xterm*} {
    howmanycolors = 8
  # force linux console to have colors
  } {~ $TERM linux} {
    howmanycolors = 8
  }
}

fn update_prompt {
  if {$howmanycolors :ge 8} {
    if {$howmanycolors :ge 256} {
      set_prompt_256
    } {
      set_prompt_8
    }
  } {
    set_prompt_nocolor
  }
}

fn update_prompt_git_status {
  let ( pgs = $prompt_git_status ) {
    if {access -d .git && access -x /usr/bin/git} {
      prompt_git_status = `{/usr/bin/git status --porcelain --branch | git_branch_decoder}
    } {
      prompt_git_status = ''
    }
    if {!~ $pgs $prompt_git_status} {
      update_prompt
    }
  }
}

update_prompt_git_status

if {$howmanycolors :ge 8} {
  # use ls colors
  imply ls '--color=auto' -aFC
  # use grep colors
  imply grep '--color=auto'
}

#
# shorten pwd to ~/dir if inside home
#
# compares dirname of pwd recursively until no more pwd left
# if:
# pwd  = /home/user/subdir
# home = /home/user
# returns ~/subdir
#
fn shorten_pwd_home {
  let ((pwd home) = $*) {
    # if no more path left to match
    if {~ $pwd '/'} {
      return ''
    }
    let (dir = `{dirname $pwd}; file = `{basename $pwd}) {
      # if dir prefix matches home
      if {~ $dir $home} {
        return '~/' ^ $file
      }
      # otherwise match one directory up
      return <={shorten_pwd_home $dir $home} ^ '/' ^ $file
    }
  }
}

# init these if not set already
if {~ $#USER 0} {USER = `{whoami}}
if {~ $#HOSTNAME 0} {HOSTNAME = `{hostname -s}}
PWD = `{pwd}

#
# calls shorten_pwd_home with PWD and HOME
#
fn get_short_pwd {
  if {~ $#HOME 0} {
    # if no home set
    return $PWD
  }
  if {~ $PWD $HOME} {
    # if already in home dir
    return '~'
  }
  # recursively match pwd with home
  return <={shorten_pwd_home $PWD $HOME}
}

# set the title of the terminal
fn get_xterm_title {
  let (BEL = \007; SHORTPWD = <={get_short_pwd}; XTITLE = \033 ^ ']0;') {
    return $XTITLE ^ $USER     ^ '@' ^
                     $HOSTNAME ^ ':' ^
                     $SHORTPWD ^ $BEL
  }
}

# make 'cd' set the xterm title
# cd is already an alias in initial.es, don't unalias it here
let (chdir = <={%whatis cd}) {
  fn cd {
    if {$chdir $*} {
      PWD = `{pwd}
      if {~ $TERM xterm*} {
        echo  -n <={get_xterm_title}
      }
      update_prompt_git_status
    }
  }
}

# set the title now
if {~ $TERM xterm*} {
  echo  -n <={get_xterm_title}
}

# load the history and log new commands of interactive prompt to this file
history = ~/.desh_history
